DOCUMENTO DE EXPLICAÇÃO DA IMPLEMENTAÇÃO DO COMPILADOR

Este documento detalha a implementação do compilador, focando nas estruturas de dados utilizadas, funcionalidades da linguagem suportadas e como os conceitos teóricos foram traduzidos para código C++.

1. VISÃO GERAL DA ARQUITETURA

O compilador segue uma arquitetura clássica de múltiplos estágios:
1.  **Análise Léxica (Scanner)**: Implementada com Flex (`scanner.l`), converte o código fonte em tokens.
2.  **Análise Sintática (Parser)**: Implementada com Bison (`parser.y`), valida a gramática e constrói a Árvore Sintática Abstrata (AST).
3.  **Análise Semântica**: Percorre a AST para verificar tipos, escopos e regras da linguagem.
4.  **Geração de Código**: Percorre a AST validada para gerar código alvo (MEPA).

2. ESTRUTURAS DE DADOS

A implementação faz uso extensivo de recursos modernos do C++ (C++11/14/17) e da Standard Template Library (STL).

2.1. Árvore Sintática Abstrata (AST)

A AST é a estrutura central que representa o programa em memória. Ela é definida em `ast/ASTNodes.hpp` e utiliza uma hierarquia de classes polimórficas.

*   **Classe Base (`ASTNode`)**: Todas as estruturas da linguagem herdam desta classe. Ela define o método virtual puro `accept(Visitor& visitor)`, permitindo o uso do padrão de projeto **Visitor** para percorrer a árvore sem modificar as classes dos nós.
*   **Hierarquia**:
    *   `Expr` (Expressões): Base para nós que retornam valores (ex: `BinaryExpr`, `NumberExpr`, `VarExpr`, `CallExpr`).
    *   `Stmt` (Comandos): Base para nós que executam ações (ex: `IfStmt`, `WhileStmt`, `AssignStmt`, `CompoundStmt`).
    *   `Decl` (Declarações): Base para declarações de variáveis e subrotinas (`VarDecl`, `ProcDecl`, `FuncDecl`).
*   **Gerenciamento de Memória**:
    *   Utiliza-se `std::shared_ptr` (provavelmente aliased como `NodePtr`) para gerenciar a vida útil dos nós. Isso evita vazamentos de memória (memory leaks) e elimina a necessidade de `delete` manual explícito na maioria dos casos, pois a memória é liberada automaticamente quando não há mais referências para o nó.
    *   Listas de elementos (como listas de comandos em um bloco ou argumentos de uma função) são armazenadas em `std::vector<NodePtr<Tipo>>`. O `std::vector` é um array dinâmico que cresce automaticamente.

Exemplo de Nó (`IfStmt`):
Armazena ponteiros inteligentes para a condição (`Expr`), o bloco "então" (`Stmt`) e o bloco "senão" opcional (`Stmt`).

2.2. Tabela de Símbolos

A Tabela de Símbolos (`semantic/SymbolTable.hpp`) é responsável por gerenciar identificadores (variáveis, funções, procedimentos) e seus escopos.

*   **Estrutura de Escopos**:
    *   Implementada como uma pilha de escopos: `std::deque<std::map<std::string, std::shared_ptr<Symbol>>> scopes`.
    *   `std::deque` (Double Ended Queue) permite inserção e remoção eficiente no final (topo da pilha).
    *   Cada escopo é um `std::map` (tabela hash ou árvore balanceada, dependendo da implementação da STL, geralmente árvore rubro-negra), que mapeia o nome do identificador (`std::string`) para suas informações (`Symbol`).
*   **Struct `Symbol`**:
    *   Armazena: `name` (nome), `category` (variável, função, etc.), `type` (tipo de dado) e `paramTypes` (lista de tipos dos parâmetros para funções/procedimentos).
*   **Lógica de Busca (`lookup`)**:
    *   A busca ocorre do escopo mais interno (topo da pilha/fim do deque) para o mais externo (início do deque). Isso garante que variáveis locais ocultem variáveis globais de mesmo nome (shadowing), conforme esperado em linguagens com escopo estático.

3. IMPLEMENTAÇÃO DAS FUNCIONALIDADES DA LINGUAGEM

3.1. Tipos e Variáveis
*   **Tipos Suportados**: `integer` e `boolean`.
*   **Declaração**: O parser agrupa declarações como `x, y: integer` em um nó `VarDecl`.
*   **Validação**: Na análise semântica, verifica-se se a variável já foi declarada no escopo atual (`existsInCurrentScope`). Se não, ela é inserida na tabela de símbolos.

3.2. Subrotinas (Funções e Procedimentos)
*   **Declaração**: `ProcDecl` e `FuncDecl` armazenam nome, parâmetros e corpo.
*   **Escopo**: Ao entrar em uma subrotina, um novo escopo é empilhado na tabela de símbolos (`enterScope`). Os parâmetros e variáveis locais são inseridos neste novo escopo. Ao sair, o escopo é desempilhado (`exitScope`).
*   **Funções**: Além de criar um escopo, o nome da função é inserido no escopo dela mesma como uma variável, permitindo a atribuição do valor de retorno (ex: `MinhaFuncao := 10`).

3.3. Controle de Fluxo
*   **If-Then-Else**: O nó `IfStmt` contém expressões e sub-comandos. O `SemanticChecker` visita a expressão de condição e verifica se o tipo resultante (`lastType`) é `boolean`.
*   **While-Do**: Similar ao `If`, o `WhileStmt` verifica se a condição é booleana antes de processar o corpo do loop.

3.4. Expressões e Operadores
*   **Precedência**: A precedência dos operadores (multiplicação antes de adição, etc.) é definida na gramática do Bison (`parser.y`) através das diretivas `%left` e `%right`. Isso garante que a árvore seja construída com a hierarquia correta.
*   **Tipagem**:
    *   A classe `SemanticChecker` usa uma variável de estado `lastType` para propagar o tipo da última expressão visitada.
    *   Em uma `BinaryExpr` (ex: `A + B`), o visitor visita `A` (atualiza `lastType`), salva o tipo, visita `B` (atualiza `lastType`), e então compara os dois tipos.
    *   Regras rígidas são aplicadas: operações aritméticas exigem inteiros, lógicas exigem booleanos, e relacionais exigem tipos iguais.

4. PADRÃO DE PROJETO VISITOR

O projeto utiliza fortemente o padrão **Visitor** para separar a lógica das operações da estrutura dos dados.

*   **Como funciona**: As classes da AST (dados) têm apenas o método `accept`. As classes de lógica (`ASTPrinter`, `SemanticChecker`, `CodeGenerator`) implementam os métodos `visit` para cada tipo de nó.
*   **Vantagem**: Permite adicionar novas operações (como um otimizador de código ou um novo gerador de código) sem precisar modificar as classes dos nós da AST. Isso mantém o código limpo e modular.

5. RESUMO TÉCNICO

*   **Linguagem de Implementação**: C++ (uso de `auto`, `std::move`, smart pointers, lambdas/iteradores).
*   **Parsing**: Bottom-up (LALR(1)) via Bison.
*   **Análise Semântica**: Passada única sobre a AST com verificação de tipos estática forte.
*   **Gerenciamento de Memória**: Automático via contagem de referência (`shared_ptr`), evitando erros comuns de C como double-free ou vazamentos.
