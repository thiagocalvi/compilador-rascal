\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{indentfirst}
\usepackage{hyperref}

\geometry{
    a4paper,
    left=3cm,
    right=2cm,
    top=3cm,
    bottom=2cm
}

\title{Relatório Técnico - Compilador Rascal}
\author{[Nome do Aluno 1] \\ [Nome do Aluno 2]}
\date{Dezembro/2025}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{2cm}
    {\Large \textbf{Nome da Instituição}} \\
    {\large Curso de Ciência da Computação} \\
    \vspace{4cm}
    {\Huge \textbf{Relatório Técnico - Compilador Rascal}} \\
    \vspace{1cm}
    {\large Disciplina: Compiladores (Profa. Valéria)} \\
    \vspace{4cm}
    {\large \textbf{Autores:}} \\
    [Nome do Aluno 1] \\
    [Nome do Aluno 2] \\
    \vfill
    {\large Dezembro/2025}
\end{titlepage}

\tableofcontents
\newpage

\section{Decisões de Projeto e Implementação}

\subsection{Linguagem e Ferramentas}
O compilador foi desenvolvido em \textbf{C++}, utilizando as ferramentas \textbf{Flex} e \textbf{Bison} para a geração dos analisadores léxico e sintático, respectivamente. A escolha do C++ visa aliar a eficiência de execução com recursos modernos de orientação a objetos, facilitando a manipulação da Árvore Sintática Abstrata (AST). O Flex foi utilizado para a tokenização eficiente da entrada, enquanto o Bison foi empregado para a análise gramatical baseada em regras de produção.

\subsection{Arquitetura da AST (Árvore Sintática)}
Foi implementada uma Árvore Sintática Abstrata (AST) explícita. A análise sintática não gera código diretamente; ela constrói essa árvore de objetos em memória para separar as etapas de análise da etapa de geração de código, facilitando a modularização e a manutenção.
A estrutura da AST encontra-se no diretório \texttt{ast/}, contendo classes como \texttt{ProgramNode}, \texttt{BlockNode}, \texttt{Stmt} (e suas subclasses \texttt{IfStmt}, \texttt{WhileStmt}, etc.) e \texttt{Expr}. O uso do padrão \textit{Visitor} (\texttt{ASTVisitor}) permite que diferentes passadas (impressão, análise semântica, geração de código) sejam implementadas de forma desacoplada da estrutura dos nós.

\section{Visão Geral dos Módulos}

\subsection{Analisador Léxico (Scanner)}
O analisador léxico foi implementado no arquivo \texttt{scanner.l}. Suas principais características são:
\begin{itemize}
    \item \textbf{Case-Sensitive}: O scanner diferencia maiúsculas de minúsculas. Palavras-chave como \texttt{program}, \texttt{var}, \texttt{begin} são reconhecidas apenas em minúsculas. Identificadores também respeitam a caixa (ex: \texttt{Var1} é diferente de \texttt{var1}).
    \item \textbf{Espaços em Branco}: Espaços, tabulações (\texttt{\textbackslash t}) e quebras de linha (\texttt{\textbackslash n}) são ignorados pelo scanner, servindo apenas como separadores de tokens.
    \item \textbf{Números}: O léxico reconhece apenas inteiros positivos (sequências de dígitos \texttt{[0-9]+}). Números negativos são tratados posteriormente na análise sintática como uma expressão unária.
    \item \textbf{Comentários}: Não há suporte para comentários no código fonte da linguagem Rascal, conforme verificado na ausência de regras para ignorar blocos de texto delimitados.
\end{itemize}

\subsection{Analisador Sintático (Parser)}
O analisador sintático, definido em \texttt{parser.y}, consome os tokens gerados pelo scanner e verifica a conformidade com a gramática da linguagem.
\begin{itemize}
    \item \textbf{Adaptação da Gramática}: Listas de comandos e declarações foram implementadas utilizando recursão à esquerda (ex: \texttt{comando\_lista: comando | comando\_lista ';' comando}), o que é eficiente para o parser LALR(1) do Bison.
    \item \textbf{Construção da Árvore}: Durante o reconhecimento das regras gramaticais, o parser instancia dinamicamente os nós da AST. Por exemplo, ao reconhecer uma estrutura \texttt{if}, um novo objeto \texttt{IfStmt} é criado e associado ao nó pai. Ao final da análise (\texttt{program}), a raiz da árvore é armazenada para as etapas subsequentes.
\end{itemize}

\subsection{Analisador Semântico}
A análise semântica é realizada pela classe \texttt{SemanticChecker} (em \texttt{semantic/SemanticChecker.cpp}), que percorre a AST validando as regras de contexto.
\begin{itemize}
    \item \textbf{Gerenciamento de Escopo}: Uma tabela de símbolos (\texttt{SymbolTable}) é utilizada para gerenciar escopos. Um novo escopo é criado ao entrar em procedimentos e funções, permitindo o sombreamento de variáveis e encapsulamento local. Blocos simples \texttt{begin/end} não criam novos escopos.
    \item \textbf{Verificações Realizadas}:
    \begin{enumerate}
        \item \textbf{Declaração Prévia}: Verifica se todas as variáveis e sub-rotinas utilizadas foram previamente declaradas no escopo visível.
        \item \textbf{Tipagem Forte}: Garante a compatibilidade de tipos em atribuições e operações. Por exemplo, operações aritméticas exigem operandos inteiros e condições de \texttt{if/while} exigem expressões booleanas.
        \item \textbf{Chamadas de Sub-rotinas}: Verifica se o número e os tipos dos argumentos passados em chamadas de função ou procedimento correspondem à declaração.
    \end{enumerate}
\end{itemize}

\subsection{Geração de Código}
O gerador de código (\texttt{CodeGenerator} em \texttt{ast/CodeGenerator.cpp}) percorre a AST validada e traduz os nós para instruções da máquina hipotética MEPA.
\begin{itemize}
    \item O gerador emite instruções mnemônicas como \texttt{INPP} (início de programa), \texttt{AMEM} (aloca memória), \texttt{CRVL} (carrega valor), \texttt{SOMA}, \texttt{PARA} (fim), entre outras.
    \item A geração é feita em uma única passada sobre a AST, escrevendo o código resultante no arquivo de saída (padrão \texttt{output.mepa}).
\end{itemize}

\section{Manual de Uso}

\subsection{Como Compilar}
O projeto utiliza um \texttt{Makefile} para automação da compilação. Para gerar o executável do compilador, abra o terminal na raiz do projeto e execute o comando:
\begin{verbatim}
make
\end{verbatim}
Este comando irá gerar o executável chamado \texttt{compilador}.

\subsection{Como Executar}
Para compilar um código fonte escrito na linguagem Rascal, utilize o seguinte comando:
\begin{verbatim}
./compilador [arquivo_entrada]
\end{verbatim}
Exemplo:
\begin{verbatim}
./compilador testes/exemplo1.ras
\end{verbatim}

O compilador lerá o arquivo de entrada especificado. Se não houver erros léxicos, sintáticos ou semânticos, o código objeto para a máquina MEPA será gerado automaticamente no arquivo \textbf{output.mepa} no diretório atual.
Caso nenhum arquivo de entrada seja fornecido, o compilador aguardará a entrada via \textit{stdin}.

\end{document}
